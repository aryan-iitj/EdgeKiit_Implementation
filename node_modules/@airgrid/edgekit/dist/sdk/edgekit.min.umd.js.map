{"version":3,"file":"edgekit.min.umd.js","sources":["../../types/index.ts","../../src/utils/index.ts","../../src/store/pageview.ts","../../src/store/matchedAudiences.ts","../../src/engine/reducers.ts","../../src/engine/matchers.ts","../../src/engine/filters/math.ts","../../src/engine/filters/guards.ts","../../src/engine/filters/conditions.ts","../../src/gdpr/index.ts","../../src/index.ts","../../src/engine/index.ts","../../src/engine/translate.ts","../../src/engine/evaluate.ts","../../src/engine/filters/index.ts"],"sourcesContent":["// Page view interfaces\n\nexport type PageFeatureResult = {\n  version: number;\n  value: number[];\n};\n\nexport type PageView = {\n  ts: number;\n  features: Record<string, PageFeatureResult>;\n  [key: string]: any;\n};\n\n// Audience definition interfaces\n\nexport type CosineSimilarityQueryValue = {\n  vector: PageFeatureResult['value'];\n  threshold: number;\n};\n\nexport type LogisticRegressionQueryValue = {\n  vector: PageFeatureResult['value'];\n  bias: number;\n  threshold: number;\n};\n\nexport enum QueryFilterComparisonType {\n  COSINE_SIMILARITY = 'cosineSimilarity',\n  LOGISTIC_REGRESSION = 'logisticRegression',\n}\n\nexport type CosineSimilarityFilter = {\n  queryValue: CosineSimilarityQueryValue;\n  queryFilterComparisonType: QueryFilterComparisonType.COSINE_SIMILARITY;\n};\n\nexport type LogisticRegressionFilter = {\n  queryValue: LogisticRegressionQueryValue;\n  queryFilterComparisonType: QueryFilterComparisonType.LOGISTIC_REGRESSION;\n};\n\nexport type AudienceDefinitionFilter =\n  | CosineSimilarityFilter\n  | LogisticRegressionFilter;\n\nexport type AudienceQueryDefinition = {\n  featureVersion: number;\n  queryProperty: string;\n} & AudienceDefinitionFilter;\n\nexport interface AudienceDefinition {\n  id: string;\n  version: number;\n  ttl: number;\n  lookBack: number;\n  occurrences: number;\n  definition: AudienceQueryDefinition[];\n}\n\n// Engine internal interfaces\n\nexport interface EngineConditionRule {\n  reducer: {\n    name: 'count';\n  };\n  matcher: {\n    name: 'eq' | 'gt' | 'lt' | 'ge' | 'le';\n    args: number;\n  };\n}\n\nexport type EngineConditionQuery<T extends AudienceDefinitionFilter> = Pick<\n  AudienceQueryDefinition,\n  'featureVersion' | 'queryProperty'\n> &\n  T;\n\nexport interface EngineCondition<T extends AudienceDefinitionFilter> {\n  filter: {\n    any?: boolean;\n    queries: EngineConditionQuery<T>[];\n  };\n  rules: EngineConditionRule[];\n}\n\n// Audience cache interfaces\n\nexport interface MatchedAudience {\n  id: string;\n  version: number;\n  matchedAt: number;\n  expiresAt: number;\n  matchedOnCurrentPageView: boolean;\n}\n\nexport type MatchedAudiences = {\n  [key: string]: MatchedAudience\n}\n\nexport interface AudienceMetaData {\n  id: string;\n  version: number;\n}\n\n// Storage interfaces\n\nexport enum StorageKeys {\n  PAGE_VIEWS = 'edkt_page_views',\n  MATCHED_AUDIENCES = 'edkt_matched_audiences',\n  MATCHED_AUDIENCE_IDS = 'edkt_matched_audience_ids',\n  CACHED_AUDIENCES = 'edkt_cached_audiences',\n  CACHED_AUDIENCE_META_DATA = 'edkt_cached_audience_meta_data',\n}\n\n// Gdpr consent interfaces\n\n// https://github.com/InteractiveAdvertisingBureau/GDPR-Transparency-and-Consent-Framework/blob/master/TCFv2/IAB%20Tech%20Lab%20-%20CMP%20API%20v2.md#tcdata\nexport interface TCData {\n  gdprApplies: boolean;\n\n  eventStatus: 'tcloaded' | 'cmpuishown' | 'useractioncomplete';\n\n  cmpStatus: 'stub' | 'loading' | 'loaded' | 'error';\n\n  /**\n   * If this TCData is sent to the callback of addEventListener: number,\n   * the unique ID assigned by the CMP to the listener function registered\n   * via addEventListener.\n   * Others: undefined.\n   */\n  listenerId?: number | undefined;\n\n  vendor: {\n    consents: { [vendorId: number]: boolean | undefined };\n  };\n}\n\nexport interface ConsentStatus {\n  eventStatus: 'tcloaded' | 'useractioncomplete' | 'cmpuishown';\n  hasConsent: boolean;\n}\n\ndeclare global {\n  interface Window {\n    __tcfapi(\n      command: 'addEventListener',\n      version: number,\n      cb: (tcData: TCData, success: boolean) => void\n    ): void;\n\n    __tcfapi(\n      command: 'removeEventListener',\n      version: number,\n      cb: (success: boolean) => void,\n      listenerId: number\n    ): void;\n  }\n}\n\n// Top level API interfaces\n\ninterface Config {\n  audienceDefinitions: AudienceDefinition[];\n  pageFeatures?: Record<string, PageFeatureResult>;\n  pageMetadata?: Record<string, string | number | boolean>;\n  vendorIds?: number[];\n  omitGdprConsent?: boolean;\n  featureStorageSize?: number;\n}\n\nexport interface Edkt {\n  run: (config: Config) => Promise<void>;\n  getMatchedAudiences: () => MatchedAudience[];\n  getCopyOfPageViews: () => PageView[];\n}\n","export const timeStampInSecs = (): number => Math.round(Date.now() / 1000);\nexport const timeout = (milliseconds: number, message: string): Promise<void> =>\n  new Promise((_, reject) => {\n    setTimeout(() => reject(new Error(message)), milliseconds);\n  });\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst get = (key: string): any => {\n  const value = localStorage.getItem(key);\n  if (!value) return undefined;\n\n  try {\n    return JSON.parse(value);\n  } catch (e) {\n    return undefined;\n  }\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\nconst set = (key: string, value: any): void => {\n  try {\n    const serialized = JSON.stringify(value);\n    localStorage.setItem(key, serialized);\n  } catch (e) {\n    // ignore...\n  }\n};\n\nconst remove = (key: string): void => {\n  try {\n    localStorage.removeItem(key);\n  } catch (e) {\n    // ignore...\n  }\n};\n\nexport const storage = {\n  set,\n  get,\n  remove,\n};\n","import { storage, timeStampInSecs } from '../utils';\nimport { PageView, StorageKeys, PageFeatureResult } from '../../types';\n\nconst DEFAULT_MAX_FEATURES_SIZE = 300;\n\nclass ViewStore {\n  private pageViews: PageView[];\n  private storageSize: number;\n\n  constructor() {\n    this.pageViews = [];\n    this.storageSize = DEFAULT_MAX_FEATURES_SIZE;\n    this._load();\n  }\n\n  _load(): void {\n    this.pageViews = storage.get(StorageKeys.PAGE_VIEWS) || [];\n  }\n\n  _save(): void {\n    storage.set(StorageKeys.PAGE_VIEWS, this.pageViews);\n  }\n\n  _trim(): void {\n    if (this.pageViews.length <= this.storageSize) return;\n    this.pageViews.sort((a: PageView, b: PageView): number => b.ts - a.ts);\n    this.pageViews = this.pageViews.slice(0, this.storageSize);\n  }\n\n  /**\n   * @param storageSize Max pageView items to be kept\n   */\n  setStorageSize(storageSize?: number): void {\n    if (!storageSize || storageSize < 0) return;\n    this.storageSize = storageSize;\n  }\n\n  savePageView(\n    features: Record<string, PageFeatureResult> | undefined,\n    metadata?: Record<string, string | number | boolean>\n  ): void {\n    if (!features || Object.keys(features).length < 1) return;\n    const ts = timeStampInSecs();\n    const pageView: PageView = {\n      ts,\n      features,\n      ...metadata,\n    };\n    this.pageViews.push(pageView);\n    this._trim();\n    this._save();\n  }\n\n  getCopyOfPageViews(): PageView[] {\n    return [...this.pageViews];\n  }\n}\n\nexport const viewStore = new ViewStore();\n","import { storage, timeStampInSecs } from '../utils';\nimport {\n  StorageKeys,\n  MatchedAudience,\n  MatchedAudiences,\n  AudienceDefinition,\n} from '../../types';\n\nclass MatchedAudienceStore {\n  private matchedAudiences: MatchedAudiences;\n  private matchedAudienceIds: string[];\n  private unsetDueToVersionIncAudienceIds: string[];\n  private storeLoadedAt: number;\n\n  constructor() {\n    this.matchedAudiences = {};\n    this.matchedAudienceIds = [];\n    this.unsetDueToVersionIncAudienceIds = [];\n    this.storeLoadedAt = timeStampInSecs();\n    this._load();\n  }\n\n  _save(): void {\n    storage.set(StorageKeys.MATCHED_AUDIENCES, this.matchedAudiences);\n    storage.set(StorageKeys.MATCHED_AUDIENCE_IDS, this.matchedAudienceIds);\n  }\n\n  _hasAudienceExpired(expiresAt: number): boolean {\n    return expiresAt < this.storeLoadedAt;\n  }\n\n  _unsetAudience(id: string): void {\n    delete this.matchedAudiences[id];\n  }\n\n  _updatePageViewFlag(id: string, state: boolean): void {\n    this.matchedAudiences[id].matchedOnCurrentPageView = state;\n  }\n\n  _load(): void {\n    // TODO: @ydennisy remove this backward compat code.\n    // https://github.com/AirGrid/edgekit/issues/152\n    let loadedAudiences: MatchedAudiences =\n      storage.get(StorageKeys.MATCHED_AUDIENCES) || {};\n\n    if (Array.isArray(loadedAudiences)) {\n      storage.remove(StorageKeys.MATCHED_AUDIENCES);\n      loadedAudiences = loadedAudiences.reduce((acc, cur) => {\n        acc[cur.id] = cur;\n      }, {});\n    }\n\n    this.matchedAudiences = loadedAudiences;\n\n    Object.entries(loadedAudiences).forEach(([id, audience]) => {\n      if (this._hasAudienceExpired(audience.expiresAt)) {\n        this._unsetAudience(id);\n        return;\n      }\n      this._updatePageViewFlag(id, false);\n    });\n\n    this.matchedAudienceIds = Object.keys(this.matchedAudiences);\n    this._save();\n  }\n\n  unsetAudiencesIfVersionIncremented(\n    audienceDefinitions: AudienceDefinition[]\n  ): void {\n    audienceDefinitions.forEach((audience) => {\n      const incomingVersion = audience.version;\n      const currentVersion = this.matchedAudiences[audience.id]\n        ? this.matchedAudiences[audience.id].version\n        : null;\n      if (currentVersion && currentVersion < incomingVersion) {\n        this._unsetAudience(audience.id);\n        this.unsetDueToVersionIncAudienceIds.push(audience.id);\n      }\n    });\n  }\n\n  isMatched(id: string, version: number): boolean {\n    return !!(\n      this.matchedAudiences[id] && this.matchedAudiences[id].version >= version\n    );\n  }\n\n  setAudiences(matchedAudiences: MatchedAudience[]) {\n    matchedAudiences.forEach((audience) => {\n      this.matchedAudiences[audience.id] = audience;\n      if (this.unsetDueToVersionIncAudienceIds.includes(audience.id)) {\n        this._updatePageViewFlag(audience.id, false);\n      }\n    });\n    this.matchedAudienceIds = Object.keys(this.matchedAudiences);\n    this._save();\n  }\n\n  getMatchedAudiences() {\n    // TODO: this is for backward compat.\n    // https://github.com/AirGrid/edgekit/issues/152\n    return Object.entries(this.matchedAudiences).map(\n      ([_, audience]) => audience\n    );\n  }\n}\n\nexport const matchedAudienceStore = new MatchedAudienceStore();\n","import { PageView } from '../../types';\n\nexport const count = () => (pageViews: PageView[]): number => pageViews.length;\n","/*\n * Example usage:\n * const greaterThan10 = gt(10);\n * greaterThan10(11) === true;\n */\n\nexport const eq = (a: number) => (b: number): boolean => a === b;\n\nexport const gt = (a: number) => (b: number): boolean => b > a;\n\nexport const lt = (a: number) => (b: number): boolean => b < a;\n\nexport const ge = (a: number) => (b: number): boolean => b >= a;\n\nexport const le = (a: number) => (b: number): boolean => b <= a;\n","const euclideanLength = (vector: number[]): number => {\n  return Math.sqrt(vector.reduce((acc, cur) => acc + Math.pow(cur, 2), 0));\n};\n\nconst cosineScaler = (x: number): number => {\n  const MAX = 0.9;\n  const MIN = -0.5;\n  const scaled = (x - MIN) / (MAX - MIN);\n  if (scaled >= 1) return 1;\n  if (scaled <= 0) return 0;\n  return scaled;\n};\n\nexport const dotProduct = (vectorA: number[], vectorB: number[]): number => {\n  return vectorA.reduce((acc, cur, idx) => acc + cur * vectorB[idx], 0);\n};\n\nexport const cosineSimilarity = (\n  vectorA: number[],\n  vectorB: number[]\n): number => {\n  const cosineSim =\n    dotProduct(vectorA, vectorB) /\n    (euclideanLength(vectorA) * euclideanLength(vectorB));\n  return cosineScaler(cosineSim);\n};\n\nexport const sigmoid = (z: number): number => {\n  return 1 / (1 + Math.exp(-z));\n};\n","import {\n  AudienceDefinitionFilter,\n  CosineSimilarityFilter,\n  LogisticRegressionFilter,\n  EngineConditionQuery,\n  CosineSimilarityQueryValue,\n  LogisticRegressionQueryValue,\n  QueryFilterComparisonType,\n} from '../../../types';\n\n/* Type Guards */\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/no-explicit-any\nexport const isNumberArray = (value: any): value is number[] =>\n  value instanceof Array && value.every((item) => typeof item === 'number');\n\nexport const isCosineSimilarityQueryValue = (\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/no-explicit-any\n  value: any\n): value is CosineSimilarityQueryValue =>\n  isNumberArray(value.vector) && typeof value.threshold === 'number';\n\nexport const isLogRegQueryValue = (\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/no-explicit-any\n  value: any\n): value is LogisticRegressionQueryValue =>\n  isNumberArray(value.vector) &&\n  typeof value.threshold === 'number' &&\n  typeof value.bias === 'number';\n\nexport const isCosineSimilarityFilterType = (\n  query: EngineConditionQuery<AudienceDefinitionFilter>\n): query is EngineConditionQuery<CosineSimilarityFilter> => {\n  return (\n    query.queryFilterComparisonType ===\n      QueryFilterComparisonType.COSINE_SIMILARITY &&\n    isCosineSimilarityQueryValue(query.queryValue)\n  );\n};\n\nexport const isLogisticRegressionFilterType = (\n  query: EngineConditionQuery<AudienceDefinitionFilter>\n): query is EngineConditionQuery<LogisticRegressionFilter> => {\n  return (\n    query.queryFilterComparisonType ===\n      QueryFilterComparisonType.LOGISTIC_REGRESSION &&\n    isLogRegQueryValue(query.queryValue)\n  );\n};\n","import { dotProduct, cosineSimilarity, sigmoid } from './math';\nimport {\n  isNumberArray,\n  isCosineSimilarityFilterType,\n  isLogisticRegressionFilterType,\n} from './guards';\nimport {\n  AudienceDefinitionFilter,\n  EngineConditionQuery,\n  PageFeatureResult,\n  CosineSimilarityQueryValue,\n  LogisticRegressionQueryValue,\n} from '../../../types';\n\nexport const versionMatches = (\n  query: EngineConditionQuery<AudienceDefinitionFilter>,\n  pageFeatures: PageFeatureResult\n): boolean => pageFeatures.version === query.featureVersion;\n\nconst isCosineSimilarityGreatherThanThreshold = (\n  queryValue: CosineSimilarityQueryValue,\n  pageFeatures: number[]\n): boolean =>\n  pageFeatures.length === queryValue.vector.length\n    ? cosineSimilarity(pageFeatures, queryValue.vector) > queryValue.threshold\n    : false;\n\nconst isLogisticRegressionGreatherThanThreshold = (\n  queryValue: LogisticRegressionQueryValue,\n  pageFeatures: number[]\n): boolean =>\n  pageFeatures.length === queryValue.vector.length\n    ? sigmoid(dotProduct(queryValue.vector, pageFeatures) + queryValue.bias) >\n      queryValue.threshold\n    : false;\n\nexport const cosineSimilarityCondition = (\n  query: EngineConditionQuery<AudienceDefinitionFilter>,\n  pageFeatures: PageFeatureResult\n): boolean =>\n  isCosineSimilarityFilterType(query) &&\n  isNumberArray(pageFeatures.value) &&\n  isCosineSimilarityGreatherThanThreshold(query.queryValue, pageFeatures.value);\n\nexport const logisticRegressionCondition = (\n  query: EngineConditionQuery<AudienceDefinitionFilter>,\n  pageFeatures: PageFeatureResult\n): boolean =>\n  isLogisticRegressionFilterType(query) &&\n  isNumberArray(pageFeatures.value) &&\n  isLogisticRegressionGreatherThanThreshold(\n    query.queryValue,\n    pageFeatures.value\n  );\n","import { TCData, ConsentStatus } from '../../types';\nimport { timeout } from '../utils';\n\nexport const WAIT_FOR_TCF_API = 10 * 1000;\n\nconst hasGdprConsent = (vendorIds: number[], tcData: TCData): boolean => {\n  const { vendor } = tcData;\n  return (\n    !!vendor &&\n    vendorIds.length > 0 &&\n    vendorIds.every((vendorId) => !!vendor.consents[vendorId])\n  );\n};\n\nconst removeListener = (tcData: TCData): Promise<boolean> => {\n  return new Promise((resolve) => {\n    if (tcData.listenerId) {\n      window.__tcfapi(\n        'removeEventListener',\n        2,\n        (success) => resolve(success),\n        tcData.listenerId\n      );\n    }\n  });\n};\n\nconst waitForTcfApi = () => {\n  return Promise.race([\n    new Promise((resolve) => {\n      let intervalId: number | null = null;\n      intervalId = window.setInterval(() => {\n        if (!!window.__tcfapi) {\n          if (!!intervalId) {\n            window.clearInterval(intervalId);\n          }\n          resolve(true);\n        }\n      }, 100);\n    }),\n    timeout(WAIT_FOR_TCF_API, 'TCF API is missing'),\n  ]);\n};\n\nexport const checkConsentStatus = async (\n  vendorIds: number[] = []\n): Promise<ConsentStatus> => {\n  await waitForTcfApi();\n  return new Promise((resolve, reject) => {\n    const callback = (tcData: TCData, success: boolean): void => {\n      const { cmpStatus } = tcData;\n      if (success && cmpStatus === 'loaded') {\n        const hasConsent = hasGdprConsent(vendorIds, tcData);\n        const { eventStatus } = tcData;\n        resolve({ eventStatus, hasConsent });\n        removeListener(tcData);\n      }\n    };\n\n    if (window.__tcfapi) {\n      window.__tcfapi('addEventListener', 2, callback);\n    } else {\n      reject(new Error('TCF API is missing'));\n    }\n  });\n};\n\nexport const waitForConsent = async (\n  vendorIds: number[] = []\n): Promise<boolean> => {\n  await waitForTcfApi();\n  return new Promise((resolve, reject) => {\n    const callback = (tcData: TCData, success: boolean): void => {\n      const { cmpStatus } = tcData;\n      if (\n        success &&\n        cmpStatus === 'loaded' &&\n        (tcData.eventStatus === 'tcloaded' ||\n          tcData.eventStatus === 'useractioncomplete')\n      ) {\n        resolve(hasGdprConsent(vendorIds, tcData));\n        removeListener(tcData);\n      }\n    };\n\n    if (window.__tcfapi) {\n      window.__tcfapi('addEventListener', 2, callback);\n    } else {\n      reject(new Error('TCF API is missing'));\n    }\n  });\n};\n\nexport const runOnConsent = async <T>(\n  vendorIds: number[],\n  callback: () => Promise<T>,\n  omitGdprConsent = false\n): Promise<T> => {\n  if (!omitGdprConsent) {\n    await waitForConsent(vendorIds);\n  }\n  const result = await callback();\n  return result;\n};\n","import { viewStore, matchedAudienceStore } from './store';\nimport * as engine from './engine';\nimport { waitForConsent } from './gdpr';\nimport { Edkt } from '../types';\n\nconst run: Edkt['run'] = async (config) => {\n  const {\n    vendorIds,\n    pageFeatures,\n    pageMetadata,\n    omitGdprConsent,\n    audienceDefinitions,\n    featureStorageSize,\n  } = config;\n\n  if (!omitGdprConsent) {\n    const hasConsent = await waitForConsent(vendorIds);\n    if (!hasConsent) return;\n  }\n\n  viewStore.setStorageSize(featureStorageSize);\n  viewStore.savePageView(pageFeatures, pageMetadata);\n\n  const pageViews = viewStore.getCopyOfPageViews();\n\n  matchedAudienceStore.unsetAudiencesIfVersionIncremented(audienceDefinitions);\n\n  const audiencesToMatch = audienceDefinitions.filter((audience) => {\n    return !matchedAudienceStore.isMatched(audience.id, audience.version);\n  });\n\n  const matchedAudiences = engine.getMatchingAudiences(\n    audiencesToMatch,\n    pageViews\n  );\n\n  matchedAudienceStore.setAudiences(matchedAudiences);\n};\n\nexport const edkt: Edkt = {\n  run,\n  getMatchedAudiences: () => matchedAudienceStore.getMatchedAudiences(),\n  getCopyOfPageViews: () => viewStore.getCopyOfPageViews(),\n};\n\nexport * from './store';\nexport * from './gdpr';\nexport * from '../types';\n","import { evaluateCondition } from './evaluate';\nimport { timeStampInSecs } from '../utils';\nimport { translate } from './translate';\nimport { PageView, AudienceDefinition, MatchedAudience } from '../../types';\n\nconst getMatchingAudiences = (\n  audienceDefinitions: AudienceDefinition[],\n  pageViews: PageView[]\n): MatchedAudience[] => {\n  const currentTS = timeStampInSecs();\n\n  return audienceDefinitions.reduce((acc, audience) => {\n    const condition = translate(audience);\n    const pageViewsWithinLookBack = pageViews.filter(\n      (pageView) =>\n        audience.lookBack === 0 || pageView.ts > currentTS - audience.lookBack\n    );\n    return evaluateCondition(condition, pageViewsWithinLookBack)\n      ? [\n          ...acc,\n          {\n            id: audience.id,\n            version: audience.version,\n            matchedAt: currentTS,\n            expiresAt: currentTS + audience.ttl,\n            matchedOnCurrentPageView: true,\n          },\n        ]\n      : acc;\n  }, [] as MatchedAudience[]);\n};\n\nexport { translate, evaluateCondition, getMatchingAudiences };\n","import {\n  AudienceDefinition,\n  EngineCondition,\n  AudienceDefinitionFilter,\n} from '../../types';\n\n/*\n * Audience to Engine translation\n *\n * Maintains union type over the translation layer\n * so it can be discriminated further below the computation\n */\nexport const translate = (\n  audienceDefinition: AudienceDefinition\n): EngineCondition<AudienceDefinitionFilter> => {\n  return {\n    filter: {\n      any: false,\n      queries: audienceDefinition.definition,\n    },\n    rules: [\n      {\n        reducer: {\n          name: 'count',\n        },\n        matcher: {\n          name: 'gt',\n          args: audienceDefinition.occurrences,\n        },\n      },\n    ],\n  };\n};\n","import * as reducers from './reducers';\nimport * as matchers from './matchers';\nimport { queryMatches } from './filters';\nimport {\n  PageView,\n  EngineCondition,\n  AudienceDefinitionFilter,\n} from '../../types';\n\n/* Filter the pageView array by matching queries\n * and evaluates if it matches the conditions\n * based on the condition reducing rules\n */\nexport const evaluateCondition = (\n  condition: Readonly<EngineCondition<AudienceDefinitionFilter>>,\n  pageViews: Readonly<PageView[]>\n): boolean => {\n  const { filter, rules } = condition;\n\n  // if no queries, do not match at all\n  if (pageViews.length === 0 || filter.queries.length === 0) {\n    return false;\n  }\n\n  /* Checks each pageView once for any matching queries\n   * and returns the filtered array containing the matched\n   * pageViews\n   *\n   * TODO Here, also, we have an opportunity to implement the\n   * internal AND logic, swapping some for every\n   * according to the value of filter.any\n   *\n   * NOTE: there is actually a semantic problem here.\n   * The filter definition specifies an 'any' switch,\n   * which defaults to false. However, the current\n   * filtering uses `some` to check the query conditions.\n   * The complete implementation here would be:\n   * ```\n   * filter.queries[filter.any ? 'some' : 'every']((query) => ...\n   * ```\n   * Yet, there is too much (testing) code depending on\n   * this defaulting to `some` and the refactor would take\n   * some time.\n   */\n  const filteredPageViews = pageViews.filter((pageView) =>\n    filter.queries.some((query) => {\n      const pageFeatures = pageView.features[query.queryProperty];\n      return queryMatches(query, pageFeatures);\n    })\n  );\n\n  return rules.every((rule) => {\n    const reducer = reducers[rule.reducer.name]();\n    const value = reducer(filteredPageViews);\n    const matches = matchers[rule.matcher.name](rule.matcher.args);\n\n    return matches(value);\n  });\n};\n","import {\n  AudienceDefinitionFilter,\n  EngineConditionQuery,\n  PageFeatureResult,\n} from '../../../types';\nimport {\n  versionMatches,\n  cosineSimilarityCondition,\n  logisticRegressionCondition,\n} from './conditions';\n\nexport const queryMatches = (\n  query: EngineConditionQuery<AudienceDefinitionFilter>,\n  pageFeatures?: PageFeatureResult\n): boolean => {\n  if (!pageFeatures || !versionMatches(query, pageFeatures)) {\n    return false;\n  }\n\n  // matches if any of the conditions are satisfied\n  return [\n    cosineSimilarityCondition,\n    logisticRegressionCondition,\n  ].some((match) => match(query, pageFeatures));\n};\n"],"names":["QueryFilterComparisonType","StorageKeys","timeStampInSecs","Math","round","Date","now","storage","key","value","serialized","JSON","stringify","localStorage","setItem","e","getItem","parse","viewStore","this","pageViews","storageSize","_load","PAGE_VIEWS","_save","_trim","length","sort","a","b","ts","slice","setStorageSize","savePageView","features","metadata","Object","keys","pageView","push","getCopyOfPageViews","matchedAudienceStore","matchedAudiences","matchedAudienceIds","unsetDueToVersionIncAudienceIds","storeLoadedAt","MATCHED_AUDIENCES","MATCHED_AUDIENCE_IDS","_hasAudienceExpired","expiresAt","_unsetAudience","id","_updatePageViewFlag","state","matchedOnCurrentPageView","loadedAudiences","Array","isArray","removeItem","reduce","acc","cur","entries","forEach","_this","unsetAudiencesIfVersionIncremented","audienceDefinitions","audience","currentVersion","_this2","version","isMatched","setAudiences","_this3","includes","getMatchedAudiences","map","euclideanLength","vector","sqrt","pow","dotProduct","vectorA","vectorB","idx","isNumberArray","every","item","cosineSimilarityCondition","query","pageFeatures","queryFilterComparisonType","COSINE_SIMILARITY","queryValue","threshold","isCosineSimilarityFilterType","scaled","isCosineSimilarityGreatherThanThreshold","logisticRegressionCondition","LOGISTIC_REGRESSION","bias","isLogisticRegressionFilterType","z","exp","isLogisticRegressionGreatherThanThreshold","hasGdprConsent","vendorIds","tcData","vendor","vendorId","consents","removeListener","Promise","resolve","listenerId","window","__tcfapi","success","waitForTcfApi","race","intervalId","setInterval","clearInterval","_","reject","setTimeout","Error","waitForConsent","cmpStatus","eventStatus","edkt","run","config","featureStorageSize","pageMetadata","currentTS","audienceDefinition","condition","filter","rules","queries","filteredPageViews","some","featureVersion","versionMatches","match","queryMatches","queryProperty","rule","reducers","reducer","name","matchers","matcher","args","matches","evaluateCondition","any","definition","occurrences","lookBack","matchedAt","ttl","engine","omitGdprConsent","hasConsent","callback"],"mappings":"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"}