export declare type PageFeatureResult = {
    version: number;
    value: number[];
};
export declare type PageView = {
    ts: number;
    features: Record<string, PageFeatureResult>;
    [key: string]: any;
};
export declare type CosineSimilarityQueryValue = {
    vector: PageFeatureResult['value'];
    threshold: number;
};
export declare type LogisticRegressionQueryValue = {
    vector: PageFeatureResult['value'];
    bias: number;
    threshold: number;
};
export declare enum QueryFilterComparisonType {
    COSINE_SIMILARITY = "cosineSimilarity",
    LOGISTIC_REGRESSION = "logisticRegression"
}
export declare type CosineSimilarityFilter = {
    queryValue: CosineSimilarityQueryValue;
    queryFilterComparisonType: QueryFilterComparisonType.COSINE_SIMILARITY;
};
export declare type LogisticRegressionFilter = {
    queryValue: LogisticRegressionQueryValue;
    queryFilterComparisonType: QueryFilterComparisonType.LOGISTIC_REGRESSION;
};
export declare type AudienceDefinitionFilter = CosineSimilarityFilter | LogisticRegressionFilter;
export declare type AudienceQueryDefinition = {
    featureVersion: number;
    queryProperty: string;
} & AudienceDefinitionFilter;
export interface AudienceDefinition {
    id: string;
    version: number;
    ttl: number;
    lookBack: number;
    occurrences: number;
    definition: AudienceQueryDefinition[];
}
export interface EngineConditionRule {
    reducer: {
        name: 'count';
    };
    matcher: {
        name: 'eq' | 'gt' | 'lt' | 'ge' | 'le';
        args: number;
    };
}
export declare type EngineConditionQuery<T extends AudienceDefinitionFilter> = Pick<AudienceQueryDefinition, 'featureVersion' | 'queryProperty'> & T;
export interface EngineCondition<T extends AudienceDefinitionFilter> {
    filter: {
        any?: boolean;
        queries: EngineConditionQuery<T>[];
    };
    rules: EngineConditionRule[];
}
export interface MatchedAudience {
    id: string;
    version: number;
    matchedAt: number;
    expiresAt: number;
    matchedOnCurrentPageView: boolean;
}
export declare type MatchedAudiences = {
    [key: string]: MatchedAudience;
};
export interface AudienceMetaData {
    id: string;
    version: number;
}
export declare enum StorageKeys {
    PAGE_VIEWS = "edkt_page_views",
    MATCHED_AUDIENCES = "edkt_matched_audiences",
    MATCHED_AUDIENCE_IDS = "edkt_matched_audience_ids",
    CACHED_AUDIENCES = "edkt_cached_audiences",
    CACHED_AUDIENCE_META_DATA = "edkt_cached_audience_meta_data"
}
export interface TCData {
    gdprApplies: boolean;
    eventStatus: 'tcloaded' | 'cmpuishown' | 'useractioncomplete';
    cmpStatus: 'stub' | 'loading' | 'loaded' | 'error';
    /**
     * If this TCData is sent to the callback of addEventListener: number,
     * the unique ID assigned by the CMP to the listener function registered
     * via addEventListener.
     * Others: undefined.
     */
    listenerId?: number | undefined;
    vendor: {
        consents: {
            [vendorId: number]: boolean | undefined;
        };
    };
}
export interface ConsentStatus {
    eventStatus: 'tcloaded' | 'useractioncomplete' | 'cmpuishown';
    hasConsent: boolean;
}
declare global {
    interface Window {
        __tcfapi(command: 'addEventListener', version: number, cb: (tcData: TCData, success: boolean) => void): void;
        __tcfapi(command: 'removeEventListener', version: number, cb: (success: boolean) => void, listenerId: number): void;
    }
}
interface Config {
    audienceDefinitions: AudienceDefinition[];
    pageFeatures?: Record<string, PageFeatureResult>;
    pageMetadata?: Record<string, string | number | boolean>;
    vendorIds?: number[];
    omitGdprConsent?: boolean;
    featureStorageSize?: number;
}
export interface Edkt {
    run: (config: Config) => Promise<void>;
    getMatchedAudiences: () => MatchedAudience[];
    getCopyOfPageViews: () => PageView[];
}
export {};
//# sourceMappingURL=index.d.ts.map