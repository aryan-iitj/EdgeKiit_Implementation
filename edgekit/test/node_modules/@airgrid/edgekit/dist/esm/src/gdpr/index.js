import { __awaiter, __generator } from "tslib";
import { timeout } from '../utils';
export var WAIT_FOR_TCF_API = 10 * 1000;
var hasGdprConsent = function (vendorIds, tcData) {
    var vendor = tcData.vendor;
    return (!!vendor &&
        vendorIds.length > 0 &&
        vendorIds.every(function (vendorId) { return !!vendor.consents[vendorId]; }));
};
var removeListener = function (tcData) {
    return new Promise(function (resolve) {
        if (tcData.listenerId) {
            window.__tcfapi('removeEventListener', 2, function (success) { return resolve(success); }, tcData.listenerId);
        }
    });
};
var waitForTcfApi = function () {
    return Promise.race([
        new Promise(function (resolve) {
            var intervalId = null;
            intervalId = window.setInterval(function () {
                if (!!window.__tcfapi) {
                    if (!!intervalId) {
                        window.clearInterval(intervalId);
                    }
                    resolve(true);
                }
            }, 100);
        }),
        timeout(WAIT_FOR_TCF_API, 'TCF API is missing'),
    ]);
};
export var checkConsentStatus = function (vendorIds) {
    if (vendorIds === void 0) { vendorIds = []; }
    return __awaiter(void 0, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, waitForTcfApi()];
                case 1:
                    _a.sent();
                    return [2 /*return*/, new Promise(function (resolve, reject) {
                            var callback = function (tcData, success) {
                                var cmpStatus = tcData.cmpStatus;
                                if (success && cmpStatus === 'loaded') {
                                    var hasConsent = hasGdprConsent(vendorIds, tcData);
                                    var eventStatus = tcData.eventStatus;
                                    resolve({ eventStatus: eventStatus, hasConsent: hasConsent });
                                    removeListener(tcData);
                                }
                            };
                            if (window.__tcfapi) {
                                window.__tcfapi('addEventListener', 2, callback);
                            }
                            else {
                                reject(new Error('TCF API is missing'));
                            }
                        })];
            }
        });
    });
};
export var waitForConsent = function (vendorIds) {
    if (vendorIds === void 0) { vendorIds = []; }
    return __awaiter(void 0, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, waitForTcfApi()];
                case 1:
                    _a.sent();
                    return [2 /*return*/, new Promise(function (resolve, reject) {
                            var callback = function (tcData, success) {
                                var cmpStatus = tcData.cmpStatus;
                                if (success &&
                                    cmpStatus === 'loaded' &&
                                    (tcData.eventStatus === 'tcloaded' ||
                                        tcData.eventStatus === 'useractioncomplete')) {
                                    resolve(hasGdprConsent(vendorIds, tcData));
                                    removeListener(tcData);
                                }
                            };
                            if (window.__tcfapi) {
                                window.__tcfapi('addEventListener', 2, callback);
                            }
                            else {
                                reject(new Error('TCF API is missing'));
                            }
                        })];
            }
        });
    });
};
export var runOnConsent = function (vendorIds, callback, omitGdprConsent) {
    if (omitGdprConsent === void 0) { omitGdprConsent = false; }
    return __awaiter(void 0, void 0, void 0, function () {
        var result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!!omitGdprConsent) return [3 /*break*/, 2];
                    return [4 /*yield*/, waitForConsent(vendorIds)];
                case 1:
                    _a.sent();
                    _a.label = 2;
                case 2: return [4 /*yield*/, callback()];
                case 3:
                    result = _a.sent();
                    return [2 /*return*/, result];
            }
        });
    });
};
//# sourceMappingURL=index.js.map